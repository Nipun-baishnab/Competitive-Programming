/// Fully trusted code , implemented by me . 

int extended_euclid(LL a,LL b,LL &x,LL &y){
    if(b==0)
    {
        x=1;
        y=0;
        return a ;
    }
    /**
    gcd = x*b + y*(a%b) ;

    gcd = x*b + y*(a-(a/b)*b) ;

    gcd = x*b + y*a - y*(a/b)*b ;

    gcd = y*a + (x-(y*(a/b)))*b ;
    /**/

    LL temp , g ;
    g=extended_euclid(b,a%b,x,y);
    temp=x-y*(a/b) , x=y , y=temp ;
    return g ;
}

LL inverse_mod(LL C){
    LL x,y;
    extended_euclid(MOD,C,x,y);
    return ((y%MOD)+MOD)%MOD;
}

int mod_expo(int a,int b){
    if(b==0)
        return 1 ;
    int x=mod_expo(a,b>>1) ;
    x=x*x%MOD ; if(b&1)x=x*a%MOD ; return x ;
}

LL ncr(LL n,LL r){
    if(r>n)
        return 0 ;
    if(Fact[0]==0)
    {
        Fact[0]=1 , Inv[0]=inverse_mod(1) ;
        for(int i=1;i<N;i++)Fact[i]=Fact[i-1]*i%MOD,Inv[i]=inverse_mod(Fact[i]) ;
    }
    r=Inv[r]*Inv[n-r]%MOD;
    return Fact[n]*r%MOD;
    /// ncr calculate using triangle formula nCr = (n-1)Cr + (n-1)C(r-1) ;
}

void Stirling_Number()
{
    s[0][0]=1 ;
    for(int i=1;i<=2000;++i)
    {
        for(int j=1;j<=2000;++j)
        {
            s[i][j] = ( s[i-1][j-1] + j*s[i-1][j] ) % MOD ;
        }
    }
}

lucas theorem . 
https://brilliant.org/wiki/lucas-theorem/

nice property of ncr 
https://codeforces.com/problemset/problem/1717/D
for(int i=1;i<=k;++i)
s+=ncr(n,i) ; 

/*catalan number 
2. 
applications : https://www.geeksforgeeks.org/applications-of-catalan-numbers/

name : counting perfect bst  
link : https://lightoj.com/problem/counting-perfect-bst
description :  given a set of numbers . find how many number of binary search tree possible .
why  : 
(i)   you need to know what is katalan number . (2n)!/((n+1)!*n!) is it's formula . 
(ii)  still it was solvable because perfect numbers won't be too much . dp will work . 
(iii) but if the constraint would be too large we must have to use catalan number . 




